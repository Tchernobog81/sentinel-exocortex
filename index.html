<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>THE LOOM : EXOCORTEX v133</title>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700;800&family=Inter:wght@300;400;700;900&display=swap" rel="stylesheet">
    
    <style>
        :root { --bg: #010102; --sidebar-bg: #050508; --border: rgba(255,255,255,0.08); --accent: #fbbf24; --bttf-grad: linear-gradient(180deg, #ff9d00 0%, #ffbd00 45%, #ffff00 100%); }
        html, body { 
            margin: 0; padding: 0; width: 100vw; height: 100dvh; 
            background-color: var(--bg); overflow: hidden; position: fixed; inset: 0; 
            font-family: 'JetBrains Mono', monospace; color: white; user-select: text;
        }

        /* LAYOUT GLOBAL */
        #viewport { position: absolute; inset: 0; display: flex; }

        /* SIDEBAR GAUCHE (Flux + L√©gende) */
        aside {
            width: 200px; height: 100%; 
            background: var(--sidebar-bg); border-right: 1px solid var(--border);
            display: flex; flex-direction: column; z-index: 20;
        }

        /* HEADER DANS SIDEBAR */
        .brand-header {
            padding: 15px; border-bottom: 1px solid var(--border);
            display: flex; flex-direction: column; gap: 10px;
        }
        .brand-title { font-size: 11px; font-weight: 900; letter-spacing: 0.1em; color: #666; text-transform: uppercase; }
        .brand-version { color: var(--accent); }
        .timer-badge { font-size: 10px; color: #10b981; font-weight: bold; white-space: nowrap; }

        /* BLOC 1: FLUX ENTRANT */
        #flux-container {
            flex: 0 0 35%; 
            border-bottom: 1px solid var(--border);
            padding: 15px; overflow: hidden; display: flex; flex-direction: column;
        }
        .section-title { font-size: 10px; color: var(--accent); font-weight: 800; text-transform: uppercase; margin-bottom: 8px; display: flex; justify-content: space-between; }
        #activity-list { overflow-y: auto; list-style: none; padding: 0; margin: 0; flex: 1; }
        #activity-list li { font-size: 10px; color: #bbb; margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.03); line-height: 1.4; }
        
        /* BLOC 2: L√âGENDE */
        #legend-container {
            flex: 1; padding: 15px; overflow-y: auto;
        }
        .legend-item { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 8px; cursor: pointer; transition: opacity 0.2s; user-select: none; }
        .legend-item:hover { opacity: 0.8; }
        .legend-item.hidden-line { opacity: 0.3; }
        .legend-left { display: flex; align-items: center; gap: 8px; overflow: hidden; }
        .legend-color { width: 10px; height: 10px; border-radius: 2px; flex-shrink: 0; }
        .legend-text { font-size: 9px; color: #888; font-weight: 700; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* ZONE GRAPHIQUE */
        main { flex: 1; position: relative; height: 100%; background: var(--bg); display: flex; flex-direction: column; }
        
        /* TOP BAR */
        .top-bar {
            height: 40px; border-bottom: 1px solid var(--border);
            display: flex; justify-content: center; align-items: center; padding: 0 20px; position: relative;
        }
        .hud-btn { font-size: 10px; font-weight: 800; color: #666; text-transform: uppercase; cursor: pointer; transition: color 0.2s; }
        .hud-btn:hover { color: white; }
        
        .bttf-btn {
            font-family: 'Inter', sans-serif; font-weight: 900; font-style: italic; letter-spacing: -0.5px;
            background: var(--bttf-grad); color: black;
            padding: 6px 16px; border-radius: 2px; border: none;
            box-shadow: 0 4px 15px rgba(255, 160, 0, 0.4); 
            transform: skewX(-10deg); font-size: 12px; text-transform: uppercase;
            transition: all 0.2s ease;
        }
        .bttf-btn:hover { transform: skewX(-10deg) scale(1.05); box-shadow: 0 0 25px rgba(255, 160, 0, 0.8); color: black; }

        /* CANVAS */
        .canvas-wrapper { flex: 1; position: relative; width: 100%; overflow: hidden; }
        canvas { cursor: default; } /* Curseur par d√©faut sur la grille */

        /* --- ECRAN DE CHARGEMENT & DEBUG (MODIFI√â) --- */
        #loading-screen { 
            position: fixed; inset: 0; background: #020205; z-index: 9000; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            font-family: 'JetBrains Mono'; transition: opacity 0.5s;
        }
        #debug-log {
            width: 80%; max-width: 600px; height: 200px; 
            background: #000; border: 1px solid #333; 
            color: #00ff00; font-size: 10px; padding: 10px; 
            overflow-y: auto; margin-top: 20px; white-space: pre-wrap;
        }
        .log-err { color: #ef4444; font-weight: bold; }
        .log-warn { color: #f59e0b; }
        #btn-emergency {
            margin-top: 20px; padding: 10px 20px; background: #333; color: white; border: 1px solid #666;
            font-size: 10px; text-transform: uppercase; cursor: pointer; display: none;
        }
        #btn-emergency:hover { background: #555; }

        #detail-card { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 90%; max-width: 600px; background: rgba(5,5,8,0.98); 
            border: 1px solid #333; padding: 2rem; z-index: 5000; display: none;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }
        #label-float { 
            --label-bg: rgba(0,0,0,0.9); --label-border: var(--accent);
            position: fixed; pointer-events: none; background: var(--label-bg); 
            border: 1px solid var(--label-border); color: #fff; padding: 5px 10px; 
            z-index: 4000; display: none; align-items: center; gap: 8px; font-size: 10px; 
            border-radius: 2px; font-weight: bold;
        }
        /* Le "fil" qui relie la bulle au point */
        #label-float::after {
            content: ''; position: absolute; left: -1px; bottom: -1px;
            width: 22px; height: 1px; background: var(--label-border);
            transform-origin: left center; transform: rotate(135deg);
        }
        .cyber-icon-frame { width: 24px; height: 24px; border: 1px solid #333; overflow: hidden; background: #000; display: flex; align-items: center; justify-content: center; font-size: 14px; }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="text-xl font-black text-white mb-2 tracking-widest">SYSTEM BOOT v133</div>
        <div class="text-xs text-zinc-500 mb-4">Connexion au sub-processeur ironique v133...</div>
        <div id="debug-log">Init v133...</div>
        <button id="btn-emergency" onclick="loadBackupData()">‚ö†Ô∏è CHARGER DONN√âES DE SECOURS (OFFLINE)</button>
    </div>

    <div id="viewport">
        <aside>
            <div class="brand-header">
                <div class="brand-title">The Loom <span class="brand-version">v133</span></div>
                <div id="timer-badge" class="timer-badge">Mise √† jour...</div>
            </div>

            <div id="flux-container">
                <div class="section-title">
                    <span>Flux Entrant (12h)</span>
                    <span id="flux-count" class="text-zinc-500">0</span>
                </div>
                <ul id="activity-list" class="scrollbar-thin">
                    <li class="italic text-zinc-700">En attente...</li>
                </ul>
            </div>

            <div id="legend-container"></div>
        </aside>

        <main>
            <div class="top-bar">
                <span id="sync-status" class="text-[9px] font-bold text-zinc-600 absolute left-4">OFFLINE</span>
                <button onclick="resetView()" class="hud-btn bttf-btn">RETOUR VERS LE FUTUR</button>
            </div>
            <div class="canvas-wrapper">
                <canvas id="loomChart"></canvas>
            </div>
        </main>
    </div>

    <div id="label-float"><div class="cyber-icon-frame"><span id="label-icon"></span></div><span id="label-text"></span></div>

    <div id="detail-card">
        <button onclick="closeDetail()" class="absolute top-4 right-4 text-zinc-500 hover:text-white text-2xl">&times;</button>
        <h2 id="card-title" class="text-2xl font-black text-white mb-2 text-amber-500 uppercase"></h2>
        <div class="flex gap-4 text-[10px] text-zinc-500 uppercase mb-4 border-b border-zinc-800 pb-2">
            <span>Source: <b id="card-who" class="text-zinc-300"></b></span>
            <span>Date: <b id="card-date" class="text-zinc-300"></b></span>
        </div>
        <div id="card-nav" class="flex gap-2 mb-4"></div> <!-- Zone pour les boutons de saut -->
        <p id="card-desc" class="text-zinc-300 italic text-sm leading-relaxed mb-6"></p>

        <!-- v117 Analysis Section -->
        <div id="card-analysis-section" class="grid grid-cols-1 md:grid-cols-2 gap-4 text-xs border-t border-zinc-800 pt-4">
            <!-- Pharmakon -->
            <div>
                <h3 class="font-bold text-amber-500 uppercase text-[10px] mb-2">Analyse Pharmakon</h3>
                <div class="w-full flex rounded-full h-2.5 bg-zinc-800 overflow-hidden">
                    <div id="pharmakon-remedy-bar" class="bg-emerald-500 h-2.5" style="width: 50%"></div>
                    <div id="pharmakon-poison-bar" class="bg-red-500 h-2.5" style="width: 50%"></div>
                </div>
                <div class="flex justify-between text-[10px] mt-1">
                    <span class="text-emerald-400">Rem√®de: <b id="pharmakon-remedy">50%</b></span>
                    <span class="text-red-400">Poison: <b id="pharmakon-poison">50%</b></span>
                </div>
            </div>
            <!-- S-Curve -->
            <div>
                <h3 class="font-bold text-amber-500 uppercase text-[10px] mb-2">Position Courbe en S</h3>
                <div class="text-zinc-300"><b id="s-curve-phase" class="text-2xl font-mono mr-2">3</b> / 5</div>
                <p id="s-curve-desc" class="text-zinc-500 text-[10px]">Phase d'acc√©l√©ration</p>
            </div>
            <!-- Convergences -->
            <div class="md:col-span-2">
                <h3 class="font-bold text-amber-500 uppercase text-[10px] mb-1">Convergences & Grand Filtre</h3>
                <p id="convergences-text" class="text-zinc-400"></p>
            </div>
            <!-- Final Note -->
            <div class="md:col-span-2 border-t border-zinc-800 pt-3 mt-2">
                 <p id="final-note-text" class="text-zinc-500 italic"></p>
            </div>
        </div>

        <div class="mt-4 text-[9px] text-zinc-700 font-mono">ID: <span id="card-stamp"></span></div>
    </div>

    <script>
        // URL
        const CLOUD_URL = 'https://script.google.com/macros/s/AKfycbwg-ZzMeSRyoaTRV-u824eQvnd8tHYxTsk-xDSK4vhYy42OnMpFrpumj2NSEaA45gP-/exec'; 
        
        // DONNEES DE SECOURS (Si le cloud plante)
        const BACKUP_DATA = [
            { "year": 1945, "value": 400, "label": "Trinity (BACKUP)", "category": "‚ò¢Ô∏è ENTROPIE" },
            { "year": 1969, "value": 5000, "label": "Apollo 11", "category": "üü£ ESPACE" },
            { "year": 1989, "value": 15000, "label": "WWW", "category": "üî¥ R√âSEAU" },
            { "year": 2026, "value": 200000, "label": "LE GENOU", "category": "‚ö™ SINGULARIT√â" }
        ];

        const COLORS = { 
            "‚ö™ SINGULARIT√â": "#ffffff", 
            "‚ú® NOOSPH√àRE": "#0ea5e9",
            "üîÆ IMAGINAIRE": "#f472b6", 
            "üü° HARDWARE": "#fbbf24", 
            "üîµ COGNITION": "#3b82f6", 
            "üî¥ R√âSEAU": "#ef4444", 
            "üü£ ESPACE": "#a855f7", 
            "üü¢ BIOTECH": "#10b981", 
            "‚ò¢Ô∏è ENTROPIE": "#f97316", 
            "üèõÔ∏è POLITIQUE": "#d946ef",
            "DEFAUT": "#9ca3af" 
        };
        
        const ICONS = {
            "‚ö™ SINGULARIT√â": "üß†",
            "‚ú® NOOSPH√àRE": "üåç",
            "üîÆ IMAGINAIRE": "üìö",
            "üü° HARDWARE": "üíæ",
            "üîµ COGNITION": "‚ö°",
            "üî¥ R√âSEAU": "üåê",
            "üü£ ESPACE": "üöÄ",
            "üü¢ BIOTECH": "üß¨",
            "‚ò¢Ô∏è ENTROPIE": "‚ò¢Ô∏è",
            "üèõÔ∏è POLITIQUE": "‚öñÔ∏è",
            "DEFAUT": "üìÇ"
        };

        const FALLBACK_IMG = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiNmYmJmMjQiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48cmVjdCB4PSIzIiB5PSIzIiB3aWR0aD0iMTgiIGhlaWdodD0iMTgiIHJ4PSIyIiByeT0iMiI+PC9yZWN0Pjwvc3ZnPg==';

        Chart.register(ChartDataLabels);
        let loomChart;
        let isHoveringLabel = false; // Flag pour g√©rer le conflit de curseur entre points et labels
        let activeCategory = null; // √âtat du focus (null = tout visible)

        // LOGGER DEBUG
        function log(msg, type="info") {
            const el = document.getElementById('debug-log');
            const time = new Date().toLocaleTimeString();
            let color = "#00ff00";
            if(type==="error") color="#ef4444";
            if(type==="warn") color="#f59e0b";
            el.innerHTML += `<div style="color:${color}">[${time}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        const decToDate = v => { if(v < 0) return Math.floor(v); const y=Math.floor(v); return `T${Math.floor((v-y)*4)+1} ${y}`; };
        const hexToRgba = (hex, a) => `rgba(${parseInt(hex.slice(1,3),16)},${parseInt(hex.slice(3,5),16)},${parseInt(hex.slice(5,7),16)},${a})`;

        async function loadData(init = false) {
            try {
                if(init) log("D√©marrage du protocole de synchronisation...");
                log(`Appel URL: ${CLOUD_URL.substring(0, 30)}...`);

                const res = await fetch(CLOUD_URL);
                log(`Status HTTP: ${res.status}`);

                if (!res.ok) throw new Error(`HTTP Error ${res.status}`);

                const text = await res.text();
                log(`Payload re√ßu: ${text.length} octets.`);
                
                // D√©tection erreur HTML Google
                if(text.trim().startsWith("<!DOCTYPE") || text.includes("<html")) {
                    throw new Error("Le serveur a renvoy√© une page HTML au lieu du JSON. V√©rifiez les permissions du script (Anyone/Anonymous).");
                }

                let json;
                try {
                    json = JSON.parse(text);
                    log(`Parsing JSON OK: ${json.length} entr√©es.`);
                } catch(e) {
                    throw new Error("JSON invalide ou corrompu.");
                }

                updateChart(json);
                updateFlux(json);
                updateLegend(json);

                if (init) {
                    handleSmartFocus(json);
                    // SUCCESS : On retire l'overlay
                    setTimeout(() => {
                        const ls = document.getElementById('loading-screen');
                        ls.style.opacity = 0;
                        setTimeout(() => ls.remove(), 500);
                    }, 500);
                }

                const d = new Date();
                const st = document.getElementById('sync-status');
                st.innerText = `LAST SYNC ${("0"+d.getHours()).slice(-2)}:${("0"+d.getMinutes()).slice(-2)}`;
                st.className = 'text-[9px] font-bold text-emerald-500 absolute left-4';

            } catch(e) {
                console.error(e);
                log(`ERREUR FATALE: ${e.message}`, "error");
                const st = document.getElementById('sync-status');
                st.innerText = "CONNEXION ERROR";
                st.className = 'text-[9px] font-bold text-red-500 absolute left-4';
                
                // Afficher le bouton de secours
                document.getElementById('btn-emergency').style.display = 'block';
            }
        }

        function loadBackupData() {
            log("Chargement donn√©es de secours...", "warn");
            updateChart(BACKUP_DATA);
            updateFlux(BACKUP_DATA);
            updateLegend(BACKUP_DATA);
            handleSmartFocus(BACKUP_DATA);
            setTimeout(() => {
                document.getElementById('loading-screen').remove();
            }, 500);
        }

        function handleSmartFocus(json) {
            const now = new Date();
            const limit = new Date(now.getTime() - (12 * 60 * 60 * 1000));
            const recent = json.filter(d => d.timestamp && new Date(d.timestamp) > limit);
            if (recent.length > 0) {
                recent.sort((a,b) => new Date(b.timestamp) - new Date(a.timestamp));
                const target = recent[0].year;
                loomChart.options.scales.x.min = target - 10;
                loomChart.options.scales.x.max = target + 10;
                log(`Focus Actu: ${target}`);
            } else {
                // Fallback to BTTF event
                const bttfEvent = json.find(d => d.label.includes("Retour vers le Futur"));
                if (bttfEvent) {
                    const targetYear = bttfEvent.year;
                    loomChart.options.scales.x.min = targetYear - 10;
                    loomChart.options.scales.x.max = targetYear + 10;
                    log(`Focus initial: Retour vers le Futur (${targetYear})`);
                } else {
                    loomChart.options.scales.x.min = 1940;
                    loomChart.options.scales.x.max = 2050;
                    log(`Focus Standard: 1940-2050`);
                }
            }
            loomChart.update();
        }

        // Applique les couleurs en fonction du focus actif
        function getStrandStyle(cat) {
            const baseColor = COLORS[cat] || COLORS["DEFAUT"];
            if (activeCategory && activeCategory !== cat) {
                // Mode Focus : on estompe les autres
                return { color: hexToRgba(baseColor, 0.1), width: 1 };
            }
            // Mode Normal ou Focus sur cette ligne
            return { color: baseColor, width: activeCategory ? 3 : 2 };
        }

        function updateChart(flatData) {
            const strands = {};
            if(!Array.isArray(flatData)) return;
            flatData.sort((a,b) => a.year - b.year);
            flatData.forEach(d => {
                let c = d.category || "DEFAUT";
                if(!COLORS[c]) c = Object.keys(COLORS).find(k => k.includes(c)) || "DEFAUT";
                
                const style = getStrandStyle(c);
                if(!strands[c]) strands[c] = { 
                    label: c, 
                    borderColor: style.color, 
                    backgroundColor: style.color, 
                    borderWidth: style.width, 
                    data: [], 
                    pointRadius: 5, // Rend les points plus visibles
                    pointHoverRadius: 8,
                    pointBorderColor: style.color,
                    pointBackgroundColor: '#010102', // Centre du "donut"
                    pointBorderWidth: 2,
                    hitRadius: 30, // Augment√© pour faciliter le clic
                    tension: 0.3 
                };
                strands[c].data.push({ x: d.year, y: d.value, ...d });
            });
            
            // Tri des datasets pour mettre la Singularit√© en dernier (au dessus) et le reste dans l'ordre
            const sortedDatasets = Object.values(strands).sort((a, b) => {
                if (a.label.includes("SINGULARIT√â")) return 1;
                if (b.label.includes("SINGULARIT√â")) return -1;
                return a.label.localeCompare(b.label);
            });

            loomChart.data.datasets = sortedDatasets;
            loomChart.update('none');
        }

        // Plugin pour dessiner les fils des √©tiquettes permanentes
        const connectorPlugin = {
            id: 'connectorPlugin',
            afterDatasetsDraw: (chart) => {
                const ctx = chart.ctx;
                chart.data.datasets.forEach((dataset, i) => {
                    const meta = chart.getDatasetMeta(i);
                    if (meta.hidden) return;
                    meta.data.forEach((element, index) => {
                        const dataPoint = dataset.data[index];
                        if (!dataPoint.tipping) return; // Seulement pour les √©tiquettes permanentes
                        if (activeCategory && dataPoint.category !== activeCategory) return; // Pas de fil si estomp√©

                        const model = element.tooltipPosition();
                        ctx.save();
                        ctx.beginPath();
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = dataset.borderColor;
                        ctx.moveTo(model.x, model.y - 4); // D√©part un peu au dessus du point
                        ctx.lineTo(model.x, model.y - 12); // Connecte au bas de l'√©tiquette (offset 12)
                        ctx.stroke();
                        ctx.restore();
                    });
                });
            }
        };

        function updateFlux(data) {
            const now = new Date();
            const limit = new Date(now.getTime() - (12 * 60 * 60 * 1000)); 
            const recent = data.filter(d => d.timestamp && new Date(d.timestamp) > limit)
                               .sort((a,b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            document.getElementById('flux-count').innerText = recent.length;
            const list = document.getElementById('activity-list');
            list.innerHTML = '';
            
            if(recent.length === 0) list.innerHTML = '<li class="italic text-zinc-700">Aucun flux r√©cent...</li>';
            else recent.forEach(item => {
                const li = document.createElement('li');
                const cat = item.category || "DEFAUT";
                const col = COLORS[cat] || '#fff';
                const mins = Math.floor((now - new Date(item.timestamp))/60000);
                const timeStr = mins < 60 ? `${mins}m` : `${Math.floor(mins/60)}h`;
                li.innerHTML = `<span style="color:${col}">${ICONS[cat] || '‚óè'}</span> <span class="text-zinc-500 mr-1">[${timeStr}]</span> ${item.label}`;
                list.appendChild(li);
            });
        }

        function updateLegend(data) {
            const counts = {};
            data.forEach(d => {
                let c = d.category || "DEFAUT";
                if(!COLORS[c]) c = Object.keys(COLORS).find(k => k.includes(c)) || "DEFAUT";
                counts[c] = (counts[c] || 0) + 1;
            });
            const container = document.getElementById('legend-container');
            const totalEvents = Object.values(counts).reduce((a, b) => a + b, 0);
            // Ajout du titre de section avec le compteur
            container.innerHTML = `<div class="section-title"><span>Cat√©gories</span><span class="text-zinc-500">${totalEvents}</span></div>`;
            
            // Ordre sp√©cifique pour la l√©gende : Singularit√© en premier
            const orderedKeys = Object.keys(COLORS).sort((a,b) => {
                if(a.includes("SINGULARIT√â")) return -1;
                if(b.includes("SINGULARIT√â")) return 1;
                return a.localeCompare(b);
            });

            orderedKeys.forEach(cat => {
                if(!counts[cat]) return;
                const div = document.createElement('div');
                div.className = 'legend-item';
                div.dataset.cat = cat;
                
                // Gestion de l'opacit√© dans la l√©gende
                if (activeCategory && activeCategory !== cat) div.style.opacity = 0.2;
                else div.style.opacity = 1;

                div.onclick = () => {
                    if (activeCategory === cat) {
                        activeCategory = null; // D√©sactive le focus
                    } else {
                        activeCategory = cat; // Active le focus
                    }
                    // Recharger le graphique avec les nouvelles couleurs
                    updateChart(loomChart.data.datasets.flatMap(d => d.data));
                    updateLegend(loomChart.data.datasets.flatMap(d => d.data));
                };
                
                // S√©parateur visuel pour la singularit√©
                if(cat.includes("SINGULARIT√â")) div.style.marginBottom = "15px";

                div.innerHTML = `<div class="legend-left"><div class="legend-color" style="background:${COLORS[cat]}"></div><div class="legend-text">${ICONS[cat] || ''} ${cat.split(' ')[1] || cat}</div></div><div class="legend-text" style="color:#444">${counts[cat]}</div>`;
                container.appendChild(div);
            });
        }

        function updateTimer() {
            const now = new Date();
            // Cible la prochaine heure pile (ex: 14:00 -> 15:00) pour s'aligner sur Sentinel
            const target = new Date(now);
            target.setHours(target.getHours() + 1, 0, 0, 0);
            
            const diff = target - now;
            const h = Math.floor(diff/3600000);
            const m = Math.floor((diff%3600000)/60000);
            document.getElementById('timer-badge').innerText = `Mise √† jour dans ${h < 10 ? '0'+h : h}:${m < 10 ? '0'+m : m}`;
        }

        function resetView() { 
            const allData = loomChart.data.datasets.flatMap(d => d.data);
            const bttfEvent = allData.find(d => d.label.includes("Retour vers le Futur"));
            if (bttfEvent) {
                const targetYear = bttfEvent.year;
                loomChart.options.scales.x.min = targetYear - 5;
                loomChart.options.scales.x.max = targetYear + 5;
                loomChart.update();
            } else {
                // Fallback si l'√©v√©nement n'est pas trouv√©
                loomChart.options.scales.x.min = 1980;
                loomChart.options.scales.x.max = 1990;
                loomChart.update();
            }
        }
        function showDetail(d) {
            document.getElementById('card-title').innerText = d.label;
            document.getElementById('card-who').innerText = d.whoWhat || "?";
            document.getElementById('card-date').innerText = Math.floor(d.x); // Affiche l'ann√©e enti√®re pour les √©v√©nements historiques
            document.getElementById('card-desc').innerText = d.description || d.how || "Aucune description.";
            document.getElementById('card-stamp').innerText = d.timestamp || "ARCHIVE";

            // Gestion des sauts temporels (Pr√©dit / R√©alis√©)
            const navContainer = document.getElementById('card-nav');
            navContainer.innerHTML = '';
            
            if (d.realYear) {
                const btn = document.createElement('button');
                btn.className = "px-2 py-1 bg-zinc-800 border border-zinc-600 text-[10px] text-white hover:bg-zinc-700 uppercase";
                btn.innerText = `Voir R√©alisation (${d.realYear})`;
                btn.onclick = () => {
                    loomChart.options.scales.x.min = d.realYear - 5;
                    loomChart.options.scales.x.max = d.realYear + 5;
                    loomChart.update();
                    closeDetail();
                };
                navContainer.appendChild(btn);
            }

            // v117 analysis fields
            const analysisSection = document.getElementById('card-analysis-section');
            if (d.s_curve_phase !== undefined) {
                analysisSection.style.display = 'grid';

                // Pharmakon
                const remedyPercent = d.pharmakon_remedy_percent || 0;
                const poisonPercent = d.pharmakon_poison_percent || 0;
                document.getElementById('pharmakon-remedy-bar').style.width = `${remedyPercent}%`;
                document.getElementById('pharmakon-poison-bar').style.width = `${poisonPercent}%`;
                document.getElementById('pharmakon-remedy').innerText = `${remedyPercent}%`;
                document.getElementById('pharmakon-poison').innerText = `${poisonPercent}%`;

                // S-Curve
                const sPhase = d.s_curve_phase;
                document.getElementById('s-curve-phase').innerText = sPhase;
                const phaseDescriptions = ["", "1: √âmergence lente", "2: Inflexion", "3: Acc√©l√©ration", "4: Plateau de maturit√©", "5: D√©clin / Saturation"];
                document.getElementById('s-curve-desc').innerText = phaseDescriptions[sPhase] || "";

                // Convergences & Final Note
                document.getElementById('convergences-text').innerText = d.grand_filter_analysis || d.convergences || "N/A";
                const finalNote = d.final_note || "";
                document.getElementById('final-note-text').innerText = finalNote ? `"${finalNote}"` : "";

            } else {
                analysisSection.style.display = 'none';
            }

            document.getElementById('detail-card').style.display = 'block';
        }
        function closeDetail() { document.getElementById('detail-card').style.display = 'none'; }

        window.onload = () => {
            const ctx = document.getElementById('loomChart');
            loomChart = new Chart(ctx, {
                type: 'line',
                data: { datasets: [] },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    layout: { padding: { left: 20, right: 50, top: 20, bottom: 20 } },
                    onClick: (e, el) => {
                        if (el.length > 0) {
                            const d = loomChart.data.datasets[el[0].datasetIndex].data[el[0].index];
                            showDetail(d);
                        }
                    },
                    scales: {
                        x: { 
                            type: 'linear', min: 1800, max: 2120, grid: { color: '#222' }, 
                            ticks: { 
                                color: '#666', 
                                callback: function(value, index, ticks) {
                                    const zoomLevel = this.chart.scales.x.max - this.chart.scales.x.min;
                                    if (zoomLevel <= 2) { // Si le zoom est de 2 ans ou moins, on affiche les trimestres
                                        return decToDate(value);
                                    }
                                    return Math.floor(value); // Sinon, on affiche juste l'ann√©e
                                } 
                            } 
                        },
                        y: { type: 'logarithmic', position: 'right', grid: { color: '#111' } }
                    },
                    plugins: [connectorPlugin], // Ajout du plugin de connexion
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }, // D√©sactive l'infobulle native (doublon)
                        datalabels: { 
                            color: '#fff', align: 'top', offset: 12, 
                            // Gestion de la transparence en mode focus
                            backgroundColor: ctx => {
                                const dp = ctx.dataset.data[ctx.dataIndex];
                                const color = COLORS[dp.category] || '#9ca3af';
                                if (activeCategory && dp.category !== activeCategory) return hexToRgba(color, 0.1);
                                return hexToRgba(color, 0.8);
                            },
                            borderColor: ctx => {
                                const dp = ctx.dataset.data[ctx.dataIndex];
                                const color = COLORS[dp.category] || '#9ca3af';
                                if (activeCategory && dp.category !== activeCategory) return hexToRgba(color, 0.1);
                                return color;
                            },
                            color: ctx => {
                                const dp = ctx.dataset.data[ctx.dataIndex];
                                if (activeCategory && dp.category !== activeCategory) return 'rgba(255,255,255,0.1)';
                                return '#fff';
                            },
                            borderWidth: 1,
                            borderRadius: 2, padding: 4, font: { size: 9, weight: 'bold' },
                            formatter: v => {
                                // On retourne toujours le label si tipping, la couleur g√®re la transparence
                                // Ajout de l'ic√¥ne dans le texte pour un design unifi√©
                                return v.tipping ? (ICONS[v.category] || '') + ' ' + v.label : null;
                            }, 
                            clip: true, // ‚úÖ CORRECTION: Coupe les labels qui sortent du cadre
                            listeners: { // Le curseur est g√©r√© ici uniquement pour les labels
                                click: c => showDetail(c.dataset.data[c.dataIndex]),
                                enter: (context) => {
                                    isHoveringLabel = true;
                                    context.chart.canvas.style.cursor = 'pointer';
                                },
                                leave: (context) => {
                                    isHoveringLabel = false;
                                    context.chart.canvas.style.cursor = 'default';
                                }
                            }
                        },
                        zoom: { 
                            zoom: { 
                                wheel: { enabled: true }, 
                                mode: 'xy' // Zoom vertical et horizontal
                            }, 
                            pan: { enabled: true, mode: 'xy' },
                            limits: { x: { minRange: 1 } } // Limite le zoom √† 1 an (4 trimestres)
                        }
                    },
                    onHover: (e, el) => {
                        // Gestion robuste du curseur (Points OU Labels)
                        const canvas = e.chart.canvas;
                        if (el.length > 0 || isHoveringLabel) {
                            canvas.style.cursor = 'pointer';
                        } else {
                            canvas.style.cursor = 'default';
                        }
                        
                        const f = document.getElementById('label-float'), img = document.getElementById('label-icon');
                        if (el.length > 0) {
                            const point = el[0].element;
                            const dataPoint = loomChart.data.datasets[el[0].datasetIndex].data[el[0].index];
                            
                            // Si le point a d√©j√† une √©tiquette permanente, on ne montre pas la surgissante
                            if (dataPoint.tipping) {
                                f.style.display = 'none';
                                return;
                            }

                            // *** FIX COULEUR HOVER LABEL ***
                            const catColor = COLORS[dataPoint.category] || COLORS['DEFAUT'];
                            // On applique le style "permanent" √† la bulle hover
                            f.style.setProperty('--label-bg', hexToRgba(catColor, 0.8));
                            f.style.setProperty('--label-border', catColor);

                            const canvasRect = canvas.getBoundingClientRect();
                            
                            f.style.display = 'flex';
                            f.style.left = (canvasRect.left + point.x + 15) + 'px';
                            f.style.top = (canvasRect.top + point.y - 15) + 'px';
                            document.getElementById('label-text').innerText = dataPoint.label; 
                            
                            // Affiche l'ic√¥ne de cat√©gorie si pas d'image sp√©cifique
                            const catIcon = ICONS[dataPoint.category] || "üìÇ";
                            img.innerHTML = dataPoint.img ? `<img src="${dataPoint.img}" style="width:100%;height:100%;object-fit:cover;">` : catIcon;
                        } else f.style.display = 'none';
                    }
                }
            });
            
            loadData(true);
            setInterval(() => loadData(false), 300000);
            setInterval(updateTimer, 60000); updateTimer();
        };
    </script>
</body>
</html>